# MIT License
# Copyright (c) 2024 QET-release


import numpy as np
from .pq import PQ

def get_Ks(n_row, n_col, M, mem_in_byte, dtype, qetv_layer):
    """
    Calculate the maximum number of codewords (Ks) that can be used within a given memory size.

    Args:
        n_row (int): Number of rows (vectors) in the dataset.
        n_col (int): Dimension of each vector.
        M (int): Number of subspaces for Product Quantization.
        mem_in_byte (int): Available memory size in bytes.
        dtype (data-type): Data type of the input vectors.
        qetv_layer (int): Number of Quantum Entanglement Tree (QET) layers.

    Returns:
        int: The maximum number of codewords that can be used.
    """
    if mem_in_byte <= 0:
        return 0

    cell_bytes = np.dtype(dtype).itemsize  # Size of each data point in bytes

    low, high = 1, n_row  # Set search range for Ks
    max_Ks = 0
    
    while low < high - 1:
        mid = (low + high) // 2
        codewords_memory = mid * n_col * cell_bytes * 8  # Memory required for codewords in bits
        bits_per_code = (mid - 1).bit_length()  # Number of bits required to represent Ks codewords
        codes_memory = n_row * M * bits_per_code  # Memory required for codes in bits
        qet_imap_memory = n_row * n_col * 0.5 * qetv_layer  # Memory required for the QET indicator map in bits
        total_memory = (codewords_memory + codes_memory + qet_imap_memory + 7) // 8  # Total memory consumption in bytes

        # Adjust search range based on whether total memory exceeds available memory
        if total_memory <= mem_in_byte:
            low = mid
        else:
            high = mid
    max_Ks = low  # Store the maximum Ks value that fits within the memory limit
    return max_Ks

class QET_Vanilla:
    """
    A class that implements Quantum Entanglement Tree (QET) for high-dimensional vectors quantization,
    based on Product Quantization (PQ).
    """

    def __init__(self, M, MemorySize=1, Ks=None, metric="l2", qetv_layer=1, verbose=False):
        """
        Initialize the QET_Vanilla encoder with an entanglement tree.

        Args:
            M (int): The number of subspaces (must divide the vector dimension evenly).
            MemorySize (int): Memory size available for the encoder, in bytes.
            Ks (int, optional): The number of codewords for each subspace. Default is None.
            metric (str): The distance metric to use ("l2" or "dot").
            qetv_layer (int): The number of entanglement layers in the Quantum Entanglement Tree.
            verbose (bool): Verbose flag for logging detailed progress.
        """
        assert metric in ["l2", "dot"], "Metric must be 'l2' or 'dot'."
        self.M = M
        self.MemorySize = MemorySize
        self.metric = metric
        self.verbose = verbose

        self.pq = None  # Placeholder for Product Quantization model
        self.imap = None  # Placeholder for indicator map
        self.Ks = Ks  # Placeholder for number of codewords
        self.qetv_layer = qetv_layer

        if qetv_layer < 0:
            raise ValueError("qetv_layer must be non-negative")

    def __eq__(self, other):
        """
        Check equality with another QET_Vanilla instance.

        Args:
            other (QET_Vanilla): Another instance to compare with.

        Returns:
            bool: True if both instances are equal, False otherwise.
        """
        if not isinstance(other, QET_Vanilla):
            return False
        return (self.pq == other.pq and
                np.array_equal(self.imap, other.imap) and
                self.qetv_layer == other.qetv_layer)

    @property
    def codewords(self):
        """
        Get the codewords generated by the PQ model.

        Returns:
            np.ndarray: The codewords for each subspace.
            Shape: (M, Ks, Ds), where Ds = D / M.
        """
        return self.pq.codewords

    @property
    def Ds(self):
        """
        Get the dimension of each sub-vector.

        Returns:
            int: Dimension of each sub-vector, Ds = D / M.
        """
        return self.pq.Ds

    def entanglement(self, vecs):
        """
        Perform the entanglement operation on input vectors, splitting each dimension into two parts.

        Args:
            vecs (np.ndarray): Input vectors of shape (n_row, n_col).

        Returns:
            tuple: Three arrays representing the smaller part, larger part, and indicator map.
        """
        if not isinstance(vecs, np.ndarray):
            raise ValueError("input type error!")
        n_row, n_col = vecs.shape
        assert n_col % 2 == 0
        dtype = vecs.dtype
        sub_dim = n_col // 2
        smaller_part = np.zeros((n_row, sub_dim), dtype=dtype)
        larger_part = np.zeros((n_row, sub_dim), dtype=dtype)
        indicator_map = np.zeros((n_row, sub_dim), dtype=bool)
        
        left_vals = vecs[:, ::2]
        right_vals = vecs[:, 1::2]
        smaller_part = np.minimum(left_vals, right_vals)
        larger_part = np.maximum(left_vals, right_vals)
        indicator_map = left_vals < right_vals

        return smaller_part, larger_part, indicator_map

    def inverse_entanglement(self, smaller_part, larger_part, indicator_map):
        """
        Reconstruct the original vectors from the entangled smaller and larger parts.

        Args:
            smaller_part (np.ndarray): The smaller values from entanglement.
            larger_part (np.ndarray): The larger values from entanglement.
            indicator_map (np.ndarray): The boolean map indicating the original positions.

        Returns:
            np.ndarray: The reconstructed vectors.
        """
        if not isinstance(smaller_part, np.ndarray) or not isinstance(larger_part, np.ndarray) or not isinstance(indicator_map, np.ndarray):
            raise ValueError("input type error!")
        n_row1, sub_dim1 = smaller_part.shape
        n_row2, sub_dim2 = larger_part.shape
        dtype1 = smaller_part.dtype
        dtype2 = larger_part.dtype
        assert sub_dim1 == sub_dim2
        assert n_row1 == n_row2
        assert dtype1 == dtype2
        n_row = n_row1
        sub_dim = sub_dim1
        dtype = dtype1

        vecs = np.zeros((n_row, 2 * sub_dim), dtype=dtype)

        indices = np.arange(sub_dim) * 2
        vecs[np.arange(n_row)[:, None], indices] = np.where(indicator_map, smaller_part, larger_part)
        vecs[np.arange(n_row)[:, None], indices + 1] = np.where(indicator_map, larger_part, smaller_part)

        return vecs

    def entanglement_tree(self, vecs, num_layer):
        """
        Perform the multi-layer entanglement operation recursively.

        Args:
            vecs (np.ndarray): Input vectors to be entangled.
            num_layer (int): The current layer of entanglement.

        Returns:
            tuple: The entangled vectors and corresponding indicator maps.
        """
        if self.qetv_layer == 0:
            idm = np.zeros(vecs.shape, dtype=bool)
            return vecs, idm
        
        if num_layer == 1:
            smaller_part, larger_part, idm = self.entanglement(vecs)
            re_vecs = np.hstack([smaller_part, larger_part])
            re_idm = idm[np.newaxis, :]  # Convert 2D indicator map to 3D
            return re_vecs, re_idm
        
        else:
            smaller_part, larger_part, idm = self.entanglement(vecs)
            vecs1, idm1 = self.entanglement_tree(smaller_part, num_layer - 1)
            vecs2, idm2 = self.entanglement_tree(larger_part, num_layer - 1)
            re_vecs = np.hstack([vecs1, vecs2])
            sublayer_idm = np.concatenate((idm1, idm2), axis=2)
            re_idm = np.concatenate((idm[np.newaxis, :], sublayer_idm), axis=0)
            return re_vecs, re_idm  

    def inverse_entanglement_tree(self, vecs, indicator_maps):
        """
        Reverse the multi-layer entanglement operation recursively.

        Args:
            vecs (np.ndarray): Entangled vectors to be reconstructed.
            indicator_maps (np.ndarray): Indicator maps from the entanglement process.

        Returns:
            np.ndarray: The reconstructed vectors.
        """
        if not isinstance(vecs, np.ndarray) or not isinstance(indicator_maps, np.ndarray):
            raise ValueError("input type error!")
        if self.qetv_layer == 0:
            return vecs
        
        num_layers = indicator_maps.shape[0]
        if num_layers == 1:
            idm = indicator_maps[0]
            smaller_part, larger_part = vecs[:, :vecs.shape[1] // 2], vecs[:, vecs.shape[1] // 2:]
            re_vecs = self.inverse_entanglement(smaller_part, larger_part, idm)
            return re_vecs
        
        else:
            idm = indicator_maps[0]
            sub_dim = vecs.shape[1] // 2
            smaller_part, larger_part = vecs[:, :sub_dim], vecs[:, sub_dim:]
            
            reconstructed_smaller_part = self.inverse_entanglement_tree(smaller_part, indicator_maps[1:, :, :sub_dim // 2])
            reconstructed_larger_part = self.inverse_entanglement_tree(larger_part, indicator_maps[1:, :, sub_dim // 2:])
            
            re_vecs = self.inverse_entanglement(reconstructed_smaller_part, reconstructed_larger_part, idm)
            return re_vecs

    def fit(self, vecs, pq_iter=20, seed=123, minit="points"):
        """
        Fit the Product Quantization (PQ) model with the entangled vectors.

        Args:
            vecs (np.ndarray): Input vectors of shape (N, D), where N is the number of vectors and D is the dimension.
            pq_iter (int): Number of iterations for training the PQ model.
            seed (int): Random seed for initializing PQ training.
            minit (str): Initialization method for PQ ("points" or other options).

        Returns:
            QET_Vanilla: The fitted model itself.
        """
        assert vecs.ndim == 2, "Input vectors should be a 2D array."
        N, D = vecs.shape
        InputType = vecs.dtype
        assert D % self.M == 0, "Input dimension must be divisible by M."

        # Determine the maximum Ks if not provided
        if self.Ks is None:
            self.Ks = get_Ks(N, D, self.M, self.MemorySize, InputType, self.qetv_layer)
        
        # Initialize the PQ model with the specified parameters
        self.pq = PQ(M=self.M, Ks=self.Ks, metric=self.metric, verbose=self.verbose) 
        
        # Perform the entanglement process to transform input vectors
        entangled_vecs, imap = self.entanglement_tree(vecs=vecs, num_layer=self.qetv_layer)
        self.imap = imap
        
        # Fit the PQ model using the entangled vectors
        self.pq.fit(vecs=entangled_vecs, iter=pq_iter, seed=seed, minit=minit)
        return self

    def encode(self, vecs):
        """
        Encode the input vectors using the PQ model after performing entanglement.

        Args:
            vecs (np.ndarray): Input vectors of shape (N, D).

        Returns:
            tuple:
                codes (np.ndarray): The PQ codes of the vectors.
                imap (np.ndarray): The indicator maps from the entanglement process.
        """
        assert vecs.dtype == self.codewords.dtype, "Input vectors must have the same dtype as the codewords."
        assert vecs.ndim == 2, "Input vectors should be a 2D array."
        
        # Perform the entanglement process on input vectors
        entangled_vecs, imap = self.entanglement_tree(vecs, num_layer=self.qetv_layer)

        # Encode the entangled vectors using the PQ model
        codes = self.pq.encode(entangled_vecs)
        return codes, imap

    def decode(self, codes, imap):
        """
        Decode the PQ codes and reverse the entanglement process to reconstruct the original vectors.

        Args:
            codes (np.ndarray): The PQ codes representing the vectors.
            imap (np.ndarray): The indicator maps from the entanglement process.

        Returns:
            np.ndarray: The reconstructed vectors.
        """
        if not (isinstance(codes, np.ndarray) and isinstance(imap, np.ndarray)):
            raise TypeError("Both codes and imap must be np.ndarray.")

        # Decode the vectors from the PQ codes
        decoded_vecs = self.pq.decode(codes)

        # Reverse the entanglement process using the indicator maps
        reconstructed_vecs = self.inverse_entanglement_tree(vecs=decoded_vecs, indicator_maps=imap)
        return reconstructed_vecs
